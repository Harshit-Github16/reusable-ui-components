{"version":3,"file":"use-merged-ref.js","sources":["../../../../../../node_modules/next/dist/client/use-merged-ref.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"useMergedRef\", {\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n});\nconst _react = require(\"react\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(null);\n    const cleanupB = (0, _react.useRef)(null);\n    // NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.\n    // (this happens often if the user doesn't pass a ref to Link/Form/Image)\n    // But this can cause us to leak a cleanup-ref into user code (e.g. via `<Link legacyBehavior>`),\n    // and the user might pass that ref into ref-merging library that doesn't support cleanup refs\n    // (because it hasn't been updated for React 19)\n    // which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.\n    // So in practice, it's safer to be defensive and always wrap the ref, even on React 19.\n    return (0, _react.useCallback)((current)=>{\n        if (current === null) {\n            const cleanupFnA = cleanupA.current;\n            if (cleanupFnA) {\n                cleanupA.current = null;\n                cleanupFnA();\n            }\n            const cleanupFnB = cleanupB.current;\n            if (cleanupFnB) {\n                cleanupB.current = null;\n                cleanupFnB();\n            }\n        } else {\n            if (refA) {\n                cleanupA.current = applyRef(refA, current);\n            }\n            if (refB) {\n                cleanupB.current = applyRef(refB, current);\n            }\n        }\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=use-merged-ref.js.map"],"names":["defineProperty","exports","value","enumerable","get","useMergedRef","_react","require$$0","refA","refB","cleanupA","useRef","cleanupB","useCallback","current","cleanupFnA","cleanupFnB","applyRef","cleanup"],"mappings":";;;;;;;;;UAEA,CAAAA,cAAW,CAAAC,OAAA,EAAA,YAAA,EAAA;MACXC,KAAE,EAAA;AAEF,KAAA,CAAA;UACA,CAAAF,cAAA,CAAAC,OAAA,EAAA,cAAA,EAAA;MACAE,UAAA,EAAA,IAAA;AACAC,MAAAA,GAAA,cAAA;AACA,QAAA,OAAAC,YAAA;AACA;AACA,KAAA,CAAA;AACAC,IAAAA,MAAAA,MAAI,GAAAC,UAAA;aAEJF,YAAAA,CAAAG,IAAA,EAAAC,IAAA,EAAA;AACAC,MAAAA,MAAAA,QAAA,GAAAJ,IAAAA,MAAA,CAAAK,MAAA,EAAA,IAAA,CAAA;YACAC,QAAA,GAAA,IAAAN,MAAA,CAAAK,MAAA,EAAA,IAAA,CAAA;;;;;;;;AAQY,MAAA,OAAA,IAAAL,MAAA,CAAAO,WAAA,EAAAC,OAAA,IAAA;AACZ,QAAA,IAAAA,OAAA,KAAA,IAAA,EAAA;AACA,UAAA,MAAAC,UAAgB,GAAAL,QAAA,CAAAI,OAAA;cAChBC,UAAA,EAAA;AACAL,YAAAA,QAAA,CAAAI,OAAA,GAAA,IAAA;YACYC,UAAI,EAAA;;AAEhB,UAAA,MAAAC,UAAA,GAAAJ,QAAA,CAAAE,OAAA;AACA,UAAA,IAAAE,UAAA,EAAA;AAEYJ,YAAAA,QAAA,CAAAE,OAAA,GAAA,IAAA;YAAAE,UAAA,EAAA;AAAA;AAAA,SAAA,MAAA;AAEZ,UAAA,IAAAR,IAAA,EAAA;AAGAE,YAAAA,QACA,CAAAI,OAAA,GAAAG,QAAA,CAAAT,IAAA,EAAAM,OAAA,CAAA;AAEA;AACQ,UAAA,IAAAL,IAAA,EAAA;AACFG,YAAAA,QAAA,CAAAE,OAAA,GAAAG,QAAA,CAAAR,IAAA,EAAAK,OAAA,CAAA;AACN;AACA;UAEAN,IAAA,EACAC,IAAA,EACA;;qBAEAQ,CAAAT,IAAmB,EAAAM,OAAA,EAAA;AACnB,MAAA,IAAA,OAAAN,IAAA,KAAA,UAAA,EAAA;AACA,QAAA,MAAAU,OAAA,GAAAV,IAAA,CAAAM,OAAA,CAAA;AACA,QAAA,IAAA,OAAAI,OAAA,KAAA,UAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;","x_google_ignoreList":[0]}