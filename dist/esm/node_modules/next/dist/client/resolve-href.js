import { __module as resolveHref } from '../../../../_virtual/resolve-href.js';
import { __require as requireQuerystring } from '../shared/lib/router/utils/querystring.js';
import { __require as requireFormatUrl } from '../shared/lib/router/utils/format-url.js';
import { __require as requireOmit } from '../shared/lib/router/utils/omit.js';
import { __require as requireUtils } from '../shared/lib/utils.js';
import { __require as requireNormalizeTrailingSlash } from './normalize-trailing-slash.js';
import { __require as requireIsLocalUrl } from '../shared/lib/router/utils/is-local-url.js';
import { __require as requireUtils$1 } from '../shared/lib/router/utils/index.js';
import { __require as requireInterpolateAs } from '../shared/lib/router/utils/interpolate-as.js';

var hasRequiredResolveHref;
function requireResolveHref() {
  if (hasRequiredResolveHref) return resolveHref.exports;
  hasRequiredResolveHref = 1;
  (function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "resolveHref", {
      enumerable: true,
      get: function () {
        return resolveHref;
      }
    });
    const _querystring = requireQuerystring();
    const _formaturl = requireFormatUrl();
    const _omit = requireOmit();
    const _utils = requireUtils();
    const _normalizetrailingslash = requireNormalizeTrailingSlash();
    const _islocalurl = requireIsLocalUrl();
    const _utils1 = requireUtils$1();
    const _interpolateas = requireInterpolateAs();
    function resolveHref(router, href, resolveAs) {
      // we use a dummy base url for relative urls
      let base;
      let urlAsString = typeof href === 'string' ? href : (0, _formaturl.formatWithValidation)(href);
      // repeated slashes and backslashes in the URL are considered
      // invalid and will never match a Next.js page/file
      const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\/\//);
      const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;
      const urlParts = urlAsStringNoProto.split('?', 1);
      if ((urlParts[0] || '').match(/(\/\/|\\)/)) {
        console.error("Invalid href '" + urlAsString + "' passed to next/router in page: '" + router.pathname + "'. Repeated forward-slashes (//) or backslashes \\ are not valid in the href.");
        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);
        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;
      }
      // Return because it cannot be routed by the Next.js router
      if (!(0, _islocalurl.isLocalURL)(urlAsString)) {
        return resolveAs ? [urlAsString] : urlAsString;
      }
      try {
        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');
      } catch (_) {
        // fallback to / for invalid asPath values e.g. //
        base = new URL('/', 'http://n');
      }
      try {
        const finalUrl = new URL(urlAsString, base);
        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);
        let interpolatedAs = '';
        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
          const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);
          const {
            result,
            params
          } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);
          if (result) {
            interpolatedAs = (0, _formaturl.formatWithValidation)({
              pathname: result,
              hash: finalUrl.hash,
              query: (0, _omit.omit)(query, params)
            });
          }
        }
        // if the origin didn't change, it means we received a relative href
        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
        return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
      } catch (_) {
        return resolveAs ? [urlAsString] : urlAsString;
      }
    }
    if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
      Object.defineProperty(exports.default, '__esModule', {
        value: true
      });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  })(resolveHref, resolveHref.exports);
  return resolveHref.exports;
}

export { requireResolveHref as __require };
//# sourceMappingURL=resolve-href.js.map
