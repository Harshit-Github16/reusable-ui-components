'use strict';

var resolveHref = require('../../../../_virtual/resolve-href.js');
var querystring = require('../shared/lib/router/utils/querystring.js');
var formatUrl = require('../shared/lib/router/utils/format-url.js');
var omit = require('../shared/lib/router/utils/omit.js');
var utils = require('../shared/lib/utils.js');
var normalizeTrailingSlash = require('./normalize-trailing-slash.js');
var isLocalUrl = require('../shared/lib/router/utils/is-local-url.js');
var index = require('../shared/lib/router/utils/index.js');
var interpolateAs = require('../shared/lib/router/utils/interpolate-as.js');

var hasRequiredResolveHref;
function requireResolveHref() {
  if (hasRequiredResolveHref) return resolveHref.__module.exports;
  hasRequiredResolveHref = 1;
  (function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "resolveHref", {
      enumerable: true,
      get: function () {
        return resolveHref;
      }
    });
    const _querystring = querystring.__require();
    const _formaturl = formatUrl.__require();
    const _omit = omit.__require();
    const _utils = utils.__require();
    const _normalizetrailingslash = normalizeTrailingSlash.__require();
    const _islocalurl = isLocalUrl.__require();
    const _utils1 = index.__require();
    const _interpolateas = interpolateAs.__require();
    function resolveHref(router, href, resolveAs) {
      // we use a dummy base url for relative urls
      let base;
      let urlAsString = typeof href === 'string' ? href : (0, _formaturl.formatWithValidation)(href);
      // repeated slashes and backslashes in the URL are considered
      // invalid and will never match a Next.js page/file
      const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\/\//);
      const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;
      const urlParts = urlAsStringNoProto.split('?', 1);
      if ((urlParts[0] || '').match(/(\/\/|\\)/)) {
        console.error("Invalid href '" + urlAsString + "' passed to next/router in page: '" + router.pathname + "'. Repeated forward-slashes (//) or backslashes \\ are not valid in the href.");
        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);
        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;
      }
      // Return because it cannot be routed by the Next.js router
      if (!(0, _islocalurl.isLocalURL)(urlAsString)) {
        return resolveAs ? [urlAsString] : urlAsString;
      }
      try {
        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');
      } catch (_) {
        // fallback to / for invalid asPath values e.g. //
        base = new URL('/', 'http://n');
      }
      try {
        const finalUrl = new URL(urlAsString, base);
        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);
        let interpolatedAs = '';
        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
          const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);
          const {
            result,
            params
          } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);
          if (result) {
            interpolatedAs = (0, _formaturl.formatWithValidation)({
              pathname: result,
              hash: finalUrl.hash,
              query: (0, _omit.omit)(query, params)
            });
          }
        }
        // if the origin didn't change, it means we received a relative href
        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
        return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
      } catch (_) {
        return resolveAs ? [urlAsString] : urlAsString;
      }
    }
    if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
      Object.defineProperty(exports.default, '__esModule', {
        value: true
      });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  })(resolveHref.__module, resolveHref.__module.exports);
  return resolveHref.__module.exports;
}

exports.__require = requireResolveHref;
//# sourceMappingURL=resolve-href.js.map
