{"version":3,"file":"resolve-href.js","sources":["../../../../../../node_modules/next/dist/client/resolve-href.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"resolveHref\", {\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n});\nconst _querystring = require(\"../shared/lib/router/utils/querystring\");\nconst _formaturl = require(\"../shared/lib/router/utils/format-url\");\nconst _omit = require(\"../shared/lib/router/utils/omit\");\nconst _utils = require(\"../shared/lib/utils\");\nconst _normalizetrailingslash = require(\"./normalize-trailing-slash\");\nconst _islocalurl = require(\"../shared/lib/router/utils/is-local-url\");\nconst _utils1 = require(\"../shared/lib/router/utils\");\nconst _interpolateas = require(\"../shared/lib/router/utils/interpolate-as\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === 'string' ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split('?', 1);\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = '';\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\n\nif ((typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) && typeof exports.default.__esModule === 'undefined') {\n  Object.defineProperty(exports.default, '__esModule', { value: true });\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=resolve-href.js.map"],"names":["defineProperty","exports","value","enumerable","get","resolveHref","_querystring","require$$0","_formaturl","require$$1","_omit","require$$2","_utils","require$$3","_normalizetrailingslash","require$$4","_islocalurl","require$$5","_utils1","require$$6","require$$7","router","href","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","length","urlParts","split","console","error","pathname","normalizedUrl","normalizeRepeatedSlashes","URL","startsWith","asPath","_"],"mappings":";;;;;;;;;;;;;;;;;;UAYA,CAAAA,cAAA,CAAAC,OAAA,EAAA,YAAA,EAAA;MACAC,KAAM,EAAA;AACN,KAAA,CAAA;UAEA,CAAAF,cAAA,CAAAC,OAAA,EAAA,aAAA,EAAA;MACAE,UAAA,EAAA,IAAA;MACAC,GAAA,EAAA,YAAA;AACA,QAAA,OAAAC,WAAA;AAIA;AAEA,KAAA,CAAA;AACIC,IAAAA,MAAAA,YAAM,GACFC,qBAAA,EAAA;AAEAC,IAAAA,MAAAA,UAAA,GAAAC,mBAAmB,EAAA;AAC3BC,IAAAA,MAAAA,KAAA,GAAAC,cAAmB,EAAA;AACnBC,IAAAA,MAAAA,MAAA,GAAAC,eAAA,EAAA;AAEAC,IAAAA,MAAAA,uBAAA,GAAAC,gCAAA,EAAA;AACQC,IAAAA,MAAAA,WAAA,GAAAC,oBAAA,EAAA;AACIC,IAAAA,MAAAA,OAAA,GAAAC,eAAA,EAAA;AAAA,IAAA,MAAA,cAAA,GAAAC,uBAAA,EAAA;AAAAf,IAAAA,SAAAA,WAAAA,CAAAgB,MAAA,EAAAC,IAAA,EAAAC,SAAA,EAAA;AACZ;AAEA,MAAA,IAAIC,IAAA;AACIC,MAAAA,IAAAA,cACH,OAAAH,IAAW,KAAA,QAAA,GAAAA,IAAA,GAAA,IAAAd,UAAA,CAAAkB,oBAChB,EAAAJ,IAAA,CAAA;AAEA;;YAEQK,gBAAcF,WAAA,CAAAG,KAAA,CAAA,oBAAA,CAAA;AACtB,MAAA,MAAAC,kBAAA,GAAAF,aAAA,GAAAF,WAAA,CAAAK,KAAA,CAAAH,aAAA,CAAA,CAAA,CAAA,CAAAI,MAAA,CAAA,GAAAN,WAAA;AAEA,MAAA,MAAAO,QAAA,GAAAH,kBAAA,CAAAI,KAAA,CAAA,GAAA,EAAA,CAAA,CAAA;AACA,MAAA,IAAA,CAAAD,QAAA,CAAA,CAAA,CAAA,IAAkB,EAAKJ,EAAAA,KAAI,CAAe,WAAA,CAAA,EAAA;QAC9BM,OAAA,CAAAC,KAAA,CAAc,gBAAA,GAAAV,WAAA,GAAgC,oCAAA,GAAAJ,MAAa,CAAAe,QAAA,GAAA,+EAAA,CAAA;AAC3D,QAAA,MAAAC,aAAY,GAAAzB,IAAAA,MAAA,CAAA0B,wBAAA,EAAAT,kBAAA,CAAA;AAEJJ,QAAAA,WACpB,IAAAE,aAAA,GAAAA,aAAkC,CAAK,CAAA,CAAA,GAAA,EACnB,IAAAU,aAAA;;;AAWZ,MAAA,IAAA,CAAA,IAAArB;eACIO,SAAA,GAAA,YACZ,IACA,WAAA;;;AAGI,QAAA,IAAA,GAAA,IAAAgB,GAAA,CAAAd,WAAA,CAAAe,UAAA,CAAA,GAAA,CAAA,GAAAnB,MAAA,CAAAoB,MAAA,GAAApB,MAAA,CAAAe,QAAA,EAAA,UAAA,CAAA;AACF,OAAA,CAAA,OAAAM,CAAA,EAAA;AAEA;QACFlB,IAAA,GAAA,IAAAe,GAAA,CAAA,GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","x_google_ignoreList":[0]}